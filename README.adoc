:linkcss:
:stylesdir: css
:stylesheet: mystyle.css
:twoinches: width='360'
:full-width: width='100%'
:three-quarters-width: width='75%'
:two-thirds-width: width='66%'
:half-width: width='50%'
:half-size:
:one-thirds-width: width='33%'
:one-quarters-width: width='25%'
:thumbnail: width='60'
:imagesdir: images
:sourcesdir: codes
:icons: font
:hide-uri-scheme!:
:figure-caption: 図
:example-caption: リスト
:table-caption: 表
:appendix-caption: 付録
:xrefstyle: short
:section-refsig:
:chapter-refsig:

:toc:

= アプリケーション開発の演習

[.lead]
Rubyの基礎とモデリングツールを使ったモデル図の作成方法を学んだので、簡単なアプリケーションを開発してみましょう。
演習の課題は、シンプルな蔵書管理アプリケーションの開発です。
コマンドプロンプトから起動して動かすRubyアプリケーションです。

:sectnums:
:sectnumlevels: 3


== 演習の準備

この演習では、分析・設計ではUMLを使ったモデル図を作成し、実装にはRubyを使います。
モデル図は、astah* Professional を使って作成します。

* `models` ディレクトリに `mybook.asta` と `ruby.asta` があることを確認しておきましょう。
* 作成した図をファイルに書き出すときは、 `images` ディレクトリに保存します。
* プログラムは、`codes` ディレクトリに保存します。


== 要求を整理する（要求分析）

=== 顧客の要求を収集する

最初は、要望を聞いて、それを開発するシステムの要件として整理します。

顧客からの要求をヒアリングなどで収集したり、顧客の困っていることを聞いてそこから要求を引き出すことを「要求の獲得」「要求の発見・開発」などといいます。
そして、得られた要求を、開発するシステムの要件に整理するのが「要求分析（要求を分籍すること）」です。

この演習では、蔵書管理に関するヒアリングは済んでいて、「 <<req01>> 」のような要求が得られたとします。

[[req01]]
.顧客から収集した要求
* 作成したシステムは「蔵書の所有者」が利用する。
* 利用者が蔵書の情報を入力すると、蔵書の情報として登録できる。
** アプリケーションが終了しても登録した情報は保存しておきたい。
* 登録してある蔵書の一覧表示がしたい。
* 不要になった蔵書があれば、保存しているファイルから削除したい。
** 削除の前には、削除する蔵書の情報を確認したい。

また、提案された操作画面は、「 <<scr01>> 、 <<scr02>> 、 <<scr03>> 、 <<scr04>> 」のようなものでした。


[[scr01]]
.蔵書管理のメイン表示
[source, console]
----
app_develop> ruby mybook.rb mybook.db # <1>
蔵書データベースファイルmybook.dbを開きました。
処理を選択します。
1. 蔵書データの一覧
2. 蔵書データの登録
3. 蔵書データの抹消
9. 終了
番号を選んでください(1,2,3,9):  # <2>
----
<1> 蔵書管理アプリケーションは、蔵書の情報を保存しているファイルを実行時に指定できる（この実行例では `mybook.db` ）。プロンプト（ `app_develop>` ）は、各自の演習用リポジトリの保存場所やリポジトリ名によって異なる。
<2> 処理を番号で選択する。

[[scr02]]
.蔵書データの一覧表示
[source, console]
----
番号を選んでください(1,2,3,9): 1
key: fujii2019
  title: アフターデジタル
  author: 藤井、尾原
  year: 2019
  isbn: 9784296101627
------
key: udagawa2019
  title: 他社と働く
  author: 宇田川
  year: 2019
  isbn: 9784910063010
------
key: asai2019
  title: 実践的ソフトウェア工学 第2版
  author: 浅井
  year: 2019
  isbn: B07QMQ72YY(ASIN)
------
----

[[scr03]]
.蔵書データの登録
[source, console]
----
番号を選んでください(1,2,3,9): 2
登録したい本のIDを入力してください: kuboaki2012 # <1>
タイトル: 作りながら学ぶRuby入門第2版 # <2>
著者: 久保秋 真 # <3>
発行年: 2012 # <4>
ISBN: 978-4797371277 #<5>
kuboaki2012を登録しました。
----
<1> IDの入力メッセージが表示されて入力待ちになり、IDを入力して改行で画定する。もし、すでに登録しているIDが指定された場合は、「XXXXXXは、すでに登録されています。」といったメッセージを表示する。
<2> 書籍のタイトルの入力メッセージが表示されて入力待ちになり、タイトルを入力して改行で画定する。
<3> 書籍の著者名の入力メッセージが表示されて入力待ちになり、著者名を入力して改行で画定する。
<4> 書籍の発行年の入力メッセージが表示されて入力待ちになり、発行年を入力して改行で画定する。
<5> 書籍のISBN番号の入力メッセージが表示されて入力待ちになり、ISBN番号を入力して改行で画定する。

[[scr04]]
.蔵書データの削除
[source, console]
----
抹消したい本のIDを入力してください: ID0001 # <1>
key: ID0001 # <2>
  title: 書籍名
  author: 著者名
  year: 2021
  isbn: 1234-1234-1234
------
削除しますか？(y/n) y # <3>
削除しました。
----
<1> IDの入力メッセージが表示されて入力待ちになり、IDを入力して改行で画定する。
<2> 該当するIDの蔵書データを表示する。もし、入力したIDに該当する蔵書情報が見つからない場合は、「XXXXXXはみつかりません。」メッセージを表示する。
<3> 削除するかどうか確認する。`n` の場合は「削除を中止しました。」といったメッセージを表示する。

=== 顧客の要求を分析する

顧客の要求を分析します。
分析にはユースケース図、ユースケース記述を使います。
ユースケース記述の代わりにアクティビティ図を使うこともあります。

作ろうとしているシステムが、だれにどのような機能やサービスを提供しようとしているのかを整理して「アクター」と「ユースケース」を描きます。

==== 【演習】要求分析のユースケース図を描く

次の手順に従って、要求分析のユースケース図を描きます。

. `mybook.asta` を開く
. モデル「01_要求分析」の中にある「要求分析のユースケース図」を開く。
. 「 <<req01>> 」を参照して、アクターを追加し、アクター名を設定する。
. 「 <<req01>> 」を参照して、このシステムがアクターに提供する機能をひとつのユースケースとして、必要なだけユースケースを追加する。
** もし、ある機能が別のサブ機能によって構成されるようであれば、ユースケースの間に `include` 関連を使ってもよい。
. アクターとユースケースの間に関連を引く。
. 作成したユースケース図を `images` ディレクトリに `usecase.svg` として書き出す。
. `mybook.asta` を保存する。

作成した図を <<usecase_svg>> に示す。

[[usecase_svg]]
.【ユースケース図】蔵書管理システムのユースケース図
image::usecase.svg[ここにみなさんが作成したユースケース図が表示される, {tree-quarters-width}]

[NOTE]
--
ファイルに書き出したら、 `git add` で管理対象に追加し、コミットしておきます。
--


==== 【演習】要求分析のユースケース記述を書く

次の手順に従って、要求分析のユースケース記述を書きます。

. ひとつのユースケースにつき、ひとつのユースケース記述を書く。
. ユースケース記述には、アクターとシステムの間のやり取りを箇条書きで書く。
** 「アクターが〜をしたら、システムが〜をする」という感じで書く。
** もし、条件等によって処理が分かれる場合には、「代替フロー」として別の手順を書く。
. すべてのユースケースについて記述を書く。
. `include` 関連を使ってユースケースから他のユースケースが利用されているときは、利用する手順のところに「ユースケースXXXを実行する」と書く。

ユースケース記述の記述例として、「 <<usecse_desc01>> 」を示します。

[[usecse_desc01]]
.【ユースケース記述】ユースケース「蔵書を登録する」のユースケース記述
. システムは所有者に登録する書籍のIDの入力を促す。
. 所有者は蔵書を登録するためのIDを決める。
. 所有者がIDを入力すると、システムはタイトルの入力を促す。
. 所有者がタイトルを入力すると、システムは著者名の入力を促す。
. 所有者が著者名を入力すると、システムは発行年の入力を促す。
. 所有者が発行年を入力すると、システムはISBN番号の入力を促す。
. 所有者がISBN番号を入力すると、システムは入力を元に蔵書データを作成し蔵書データベースに登録する。


他のユースケースについて、同様の記述を書きます。

[[usecse_desc02]]
.【ユースケース記述】ユースケース「XXXXX」のユースケース記述
. システムが〜したら、アクターが〜する。
. アクターが〜したら、システムが〜する。



[[usecse_desc03]]
.【ユースケース記述】ユースケース「YYYYY」のユースケース記述
. システムが〜したら、アクターが〜する。
. アクターが〜したら、システムが〜する。

[NOTE]
--
ユースケース記述を書いているときにユースケースを見直す必要が生じたら、ユースケース図に戻って修正し、ファイルを書き出し直します。
--


[NOTE]
--
ユースケース記述が書けたら、コミットしておきます。
--


== 開発環境と資源を整理する（システム分析）


=== 開発に使用する環境や資源を整理する

開発に使用する環境や資源を整理します。
たとえば、実装にはRubyを使うことが決まっています。

[[sysana01]]
.開発に使う環境や資源
. 実装に使う言語は、Rubyとする。
. 分析・設計のモデル図はUML図を使う。
. UML図の作成には astah* Professional を使う。
. **ほかにあればここに追記する**

=== 不足する技術等を調査する


「 <<req01>> 」には「アプリケーションが終了しても登録した情報は保存しておきたい。」という要求があります。
しかし、わたしたちは、蔵書データのような構造を持つデータをファイルに保存する方法については、どのような方法を使えばよいかわかっていません。
このような、利用技術や知識等について不確か・未習得なことがある場合、システム分析において調査や実験を実施して利用技術や知識等を獲得します。
そして、設計や実装の際は、ここで獲得した技術等を使うことを前提に開発を進めます。

==== 【演習】コマンドライン引数を取得する

「 <<scr01>> 」をみると「蔵書管理アプリケーションは、蔵書の情報を保存しているファイルを実行時に指定できる」とあります。
このことを実現するには、システムの実行時に、保存しているファイル名を受け取る方法が必要です（ <<exec_mybook>> ）。

[[exec_mybook]]
.叢書管理のアプリケーションを実行する
[example]
--
[source, console]
----
app_develop> ruby mybook.rb mybook.db # <1>
----
<1> `ruby` のプログラム `mybook.rb` を実行するときに、プログラムが `mybook.db`  を受け取る方法が必要。
--

このような、プログラムの実行時にプログラムへ渡すパラメータのことを「コマンドライン引数」といいます。
Rubyでは、コマンドライン引数は `ARGV` という名前の「文字列の配列」に格納されています。

このコマンドライン引数の使い方を演習しておきましょう。

`codes` ディレクトリに `argv_test.rb` を作成します（ <<argv01>> ）。

[[argv01]]
.【Ruby】コマンドライン引数を使う `argv_test.rb`
[example]
--
[source,ruby,linenums]
----
# frozen_string_literal: true

ARGV.each_with_index do |arg, i| # <1>
  puts "ARGV[#{i}]: #{arg}" # <2>
end
----
<1> ARGVの要素を1つずつ処理する。 `each_with_index` メソッドを使うと、要素だけでなく添字も取得できる。
<2> 取得した添字と要素（コマンドライン上の文字列）を表示した。
--

作成できたら、実行してみます。

[[argv01_exec]]
.【Console】 `argv_test.rb` を実行する（例）
[example]
--
[source,console,linenums]
----
app_develop\codes> ruby argv_test.rb AAA BBB CCC
ARGV[0]: AAA
ARGV[1]: BBB
ARGV[2]: CCC
----
--

みなさんは、別の文字列を引数に渡して実行し、その結果を <<argv01_exec_w>> に貼っておいてください。

[[argv01_exec_w]]
.【Console】 `argv_test.rb` を実行する（みなさんの実行結果）
[example]
--
[source,console,linenums]
----
別の文字列をコマンドライン引数に指定して実行し、その結果をここに貼る。
----
--

[NOTE]
--
実験がうまくいったら、一度コミットします。
--

==== 【演習】構造のあるデータをファイルに保存する

次に、蔵書データのような構造を持つデータをファイルに保存する方法についてです。

この演習の蔵書データの場合、いずれの蔵書データにおいえも `ID` 、 `タイトル` …、といった項目があって、並びも同じです。
そうてあれば、各項目のデータをカンマ（ `,` ）で区切って並べ、1件分で1行分として改行する形式が使えます。
このような形式のファイルを「CSVファイル（ Comma Separated value ファイル）といいます。
Rubyには、CSVファイルを読み書きするためのライブラリが用意されています。

また、Rubyには、ハッシュと同じように読み書きできる「PStore」という簡易データベースライブラリがあります。
CSVファイルの場合、ファイル上のデータ構造と、プログラム中で使うデータ構造を別々に考える必要がありました。
これに対してPStoreは、 `Hash` クラスを使ったデータ構造であれば、ファイル上のデータ構造とプログラム内部で使うデータ構造を別々に考えずに使えます。
（内部的に `Marshal` クラスを使ってファイルに入出力しています）

この演習で作る蔵書管理アプリケーションでは、PStoreを使うことにします。
簡単なプログラムを作って、 PStoreの使い方を獲得しましょう（ <<pstore_sample01>> ）。
PStoreデータベースを読み書きするときには、 `transaction` メソッドの `do` 〜 `end` ブロックで囲みます。
このことを除けば、 `Hash` クラスのインスタンスの読み書きと同ようにプログラムを書けるのがわかります。


[[pstore_sample01]]
.【Ruby】PStoreデータベースを使う
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/pstore_test.rb[]
----
<1> PStoreを使うときには、ライブラリ `pstore` をrequireする。
<2> PStoreを使ったデータベースを作成する。
<3> PStoreにデータを書き込むときは、 `transaction` メソッドの `do` 〜 `end` ブロックで囲む。
<4> PStoreに保存されるのは、transactionメソッドを抜けるとき。
<5> 読み込み専用のときは true を指定する（誤って書き込なまいようにする）。
--

みなさんは、`codes` ディレクトリの <<pstore_sample01>> を実行し、その結果を <<pstore_sample01_exec_w>> に貼っておいてください。

[[pstore_sample01_exec_w]]
.【Console】 `pstore_test.rb` を実行する（みなさんの実行結果）
[example]
--
[source,console,linenums]
----
`pstore_test.rb` を実行し、その結果をここに貼る。
----
--

[NOTE]
--
実験がうまくいったら、一度コミットします。
--

=== 実装方式を決める（方式設計）

方式設計では、設計の指針や設計書と実装（コード）の対応づけルールなどを決定します。
設計のときは、方式設計で決めた作成方法を使うことを前提に設計し、設計書のモデル図を作成します。


==== パッケージやライブラリの依存関係

パッケージは、同じ関心事にかかわるクラスを集めたものを表すのに使います。
Rubyでは、Rubyが提供するライブラリ（ PStoreなど ）や自分で作成したクラス群をまとめたファイルに対応します。

たとえば、クラス図に <<pkg_to_file_svg>> のような図があったとします。

[[pkg_to_file_svg]]
.【クラス図】パッケージの依存関係
image::pkg_to_file.svg[]

この図を実装するときは、パッケージ名を小文字に変えたファイル名 `pkg1.rb` と `pkg2.rb` を用意します。
Rubyのライブラリの場合は、ステレオタイプ `lib` をつけて区別します。また、ファイルは用意しません（すでにRubyが提供しているので）。

破線矢印は、依存関係を表します。
<<pkg_to_file_svg>> では、 Pkg1 に含まれるクラスが、 Pkg2 に含まれるクラスと PStore を使っている（依存している）ことになります。
この依存関係をRubyで実装するときは、 <<pkg1_rb>> のように require_relative 宣言を使うことにします。
また、Rubyのライブラリに依存している場合は require  宣言を使います。

[[pkg1_rb]]
.【Ruby】 `pkg1.rb` 
[example]
--
[source,ruby,linenums]
----
require 'pstore' # <1>
require_relative 'pkg2' # <2>

# Pkg1 に含まれるクラスの定義が続く
----
<1> PStoreのようなRubyが提供しているライブラリを使うときは、require宣言を使う。
<2> Pkg1 が Pkg2 に依存している場合、ファイル `pkg1.rb` でファイル `pkg2.rb` をrequire_relativeする。このとき、拡張子の `.rb` は省略する。
--

==== クラスの定義場所

クラスは、パッケージの中に定義します。
たとえば、 `AAAA` クラスと `CCCC` クラスが Pkg3パッケージに定義されているなら、 <<pkg_and_class>> のように図を作成します。
とくに、構造ツリーにおいて、Pkg3 の下位構造に `AAAA` と `CCCC` が含まれていることに注意します。


[[pkg_and_class]]
.クラスはパッケージの中に定義する
image::pkg_and_class.png[{full-width}]

Rubyで実装するときは、所属するパッケージを表すファイルに定義します。
たとえば、 <<pkg_and_class>> を実装する場合、 `pkg3.rb` にこれらのクラスを定義します（ <<pkg3_rb>> ）。

[[pkg3_rb]]
.【Ruby】 `pkg3.rb` 
[example]
--
[source,ruby,linenums]
----
class AAAA
  # クラスの定義
end

class CCCC
  # クラスの定義
end
----
--

==== クラスの定義

クラスの定義を実装する場合、クラスの属性、操作、コンストラクタをRubyで実装します。
たとえば、 <<pkg_and_class>> の場合は <<class_def_rb>> のように定義します。

[[class_def_rb]]
.【Ruby】 `pkg3.rb` 
[example]
--
[source,ruby,linenums]
----
# <1> 

class CCCC # <2>
  def op_ca
    # メソッドの中身を書く
  end
end

class AAAA # <3>
  attr_accessor :aaaaa, :bbbbb

  def initialize(aaa, bbb)
    @aaaaa = aaa
    @bbbbb = bbb
    @ccc = nil # <4>
  end

  def op_a
    # メソッドの中身を書く
  end

  def op_b
    # メソッドの中身を書く
  end
end
----
<1> 必要な宣言があれば、ここに書く。
<2> `CCCC` クラスの定義のはじまり。
<3> `AAAA` クラスの定義のはじまり。
<4> `AAAA` クラスから参照する `CCCC` クラスへの関連に使う属性。関連のための変数名 `ccc` は、クラス図で `AAAA` からみた `CCCC` への関連端名を使っている。多重度が `0..1` なので、ひとつの値を持つ変数で、初期値を `nil` にしている。
--

== システムと外部のやり取りを整理する（外部設計）

外部設計では、システムと外部とのやり取りを整理します。

=== システムの構造をモデルを作成する

外部設計のやり取りを整理するために、システムの機能を提供するクラスを外部設計のクラス図に追加します。
このクラスは、あとでクラスとアクターのやり取りを整理するのに使います。

==== 【演習】パッケージとクラスを追加する


「外部設計のクラス図」に、アプリケーション用のパッケージ「App」を追加します。

. モデル「03_外部設計」の中にある「外部設計のクラス図」を開く。
. パッケージ `App` を開く。
. パッケージ `App` の中に、 `MyBook` クラスを追加する。
** <<pkg_and_class>> を参考に、構造ツリーに追加してから図を更新する。
** 振舞いを整理するまでは、操作や属性は追加しなくてよい。 
. 作成したクラス図を `images` ディレクトリに `gaibu_design_class01.svg` として書き出す。

みなさんが作成した外部設計のクラス図を <<gaibu_design_class01_svg>> に貼っておいてください。

[[gaibu_design_class01_svg]]
.【クラス図】蔵書管理システムの外部設計のクラス図
image::gaibu_design_class01.svg[ここにみなさんが作成したクラス図が表示される, {tree-quarters-width}]

[NOTE]
--
ファイルに書き出したら、 `git add` で管理対象に追加し、コミットしておきます。
--


=== システムの振舞いのモデルを作成する

システムと外部（アクター）のやり取りを整理するために、振舞いのモデルを追加します。


==== 【演習】「蔵書を登録する」の振舞いのモデルを確認する


モデル「03_外部設計」にある「外部設計の「蔵書データを登録する」のアクティビティ図（ <<gaibu_acitivity_register_book_svg>> ）」、「同シーケンス図（ <<gaibu_sequence_register_book_svg>> ）」を参照して、叢書を登録するときの外部設計の振舞いを確認します。

[[gaibu_acitivity_register_book_svg]]
.外部設計の「蔵書データを登録する」のアクティビティ図
image::gaibu_acitivity_register_book.svg[{full-width}]

[[gaibu_sequence_register_book_svg]]
.外部設計の「蔵書データを登録する」のシーケンス図
image::gaibu_sequence_register_book.svg[{full-width}]

==== 【演習】他の処理の振舞いのモデルを追加する

「 <<req01>> 」を参照して、他の処理についても振舞いのモデルを追加します。

. モデル「03_外部設計」にシーケンス図やアクティビティ図を追加する。
. 図にアクターを追加するときは、モデル「01_要求分析」から引用する。
. 「蔵書を登録する」を真似て、各図を作成する。
. 作成した図をファイルに書き出す。
** ファイル名は、下記に合わせておく。

[[gaibu_acitivity_unregister_book_svg]]
.外部設計の「蔵書データを削除する」のアクティビティ図
image::gaibu_acitivity_unregister_book.svg[{full-width}]

[[gaibu_sequence_unregister_book_svg]]
.外部設計の「蔵書データを削除する」のシーケンス図
image::gaibu_sequence_unregister_book.svg[{full-width}]

[NOTE]
--
ファイルに書き出したら、 `git add` で管理対象に追加し、コミットしておきます。
--



[[gaibu_acitivity_list_books_svg]]
.外部設計の「蔵書データの一覧表示 」のアクティビティ図
image::gaibu_acitivity_list_books.svg[{full-width}]

[[gaibu_sequence_list_books_svg]]
.外部設計の「蔵書データの一覧表示 」のシーケンス図
image::gaibu_sequence_list_books.svg[{full-width}]

[NOTE]
--
ファイルに書き出したら、 `git add` で管理対象に追加し、コミットしておきます。
--


みなさんが作成した外部設計のクラス図を <<gaibu_design_class02_svg>> に貼っておいてください（ファイル名を変えるのを忘れないこと）。

[[gaibu_design_class02_svg]]
.【クラス図】蔵書管理システムの外部設計のクラス図（操作の追加後）
image::gaibu_design_class02.svg[ここにみなさんが作成したクラス図が表示される, {tree-quarters-width}]

[NOTE]
--
ファイルに書き出したら、 `git add` で管理対象に追加し、コミットしておきます。
--

=== システムの振舞いをクラス図に反映する

先に作成したクラス図は、操作が記載されていませんでした。
振舞いを整理できたので、振舞いのモデルを参照しながら、クラスに操作を追加します。

==== 【演習】システムのクラスに操作を追加する

`MyBook` クラスに、システムが提供する機能を操作として追加しましょう。

. シーケンス図で、`MyBook` クラスが受け取っているメッセージのなかで、「 <<req01>> 」の処理を始めるきっかけになるメッセージを探す。
. そのメッセージを `MyBook` クラスの操作に追加する。
. すべての処理について、上記を繰り返す。


[NOTE]
--
ファイルに書き出したら、 `git add` で管理対象に追加し、コミットしておきます。
--



== システムの内部構造と振舞いを整理する（内部設計）

内部設計では、システムを構成する要素とその関係で内部構造を整理します。
また、それらの要素の間のやり取りを振舞いとして整理します。

=== システムの内部構造を整理する

モデル「04_内部設計」に、「内部構造のクラス図」を用意しておきました（ <<naibu_design_class01_svg>> ）。
みなさんが外部設計までに作成したモデル図と比べて、対応づくところを調べてみてください。
必要があれば、用意したクラス図を修正・変更してもかまいません。


[[naibu_design_class01_svg]]
.【クラス図】蔵書管理システムの内部設計のクラス図
image::naibu_design_class01.svg[あらかじめ用意した内部設計のクラス図, {tree-quarters-width}]



== プログラムを作成する（実装）

ユースケース記述や、内部設計のモデル図、システム分析で決めた実装方式などを参照して、ブログラムを実装しましょう。

=== 実装に必要なファイルを用意する

システム分析のときに決めた方式設計に従って、実装に使うファイルを用意します。

==== 【演習】実装に使うファイルを追加する

`codes` ディレクトリに、実装に使うファイルを追加しましょう。


. パッケージに合わせて `codes` ディレクトリに `app.rb` と `bookInfo.rb` を作成します。
. `ruby` パッケージは、Rubyが提供しているものを表しているので、ファイルを追加する必要はありません。
. 内部設計のクラス図のクラスの参照関係からファイルの間の依存関係を調べ、それぞれのファイルの先頭に `require` や `require_relative` 宣言を追加します。

[TIP]
--
`main` クラスに相当するファイルと処理は、あらかじめ `main.rb` として用意してあります。
--

[NOTE]
--
ファイルを追加できたら、 `git add` で管理対象に追加し、コミットしておきます。
--


==== 【演習】クラスとメソッドを追加する

追加したファイルに、クラスとメソッドを追加します。

. `app.rb` には、 `MyBook` クラスを作成します。
. `bookinfo.rb` には、 `BookInfo` クラスと `BookInfoDB` クラスを追加します。
. 外部設計のシーケンス図やユースケース記述を参照して、それぞれのクラスのメソッドを実装します。

[NOTE]
--
実装が少し進むたびに、コミットしておきます。
--


== プログラムをテストする（テスト）

プログラムが作成できたら、テストしましょう。

. まず、 `BookInfo` クラスや `BookInfoDB` クラスをテストします。
. うまく動作したら、 `MyBook` クラスや `main` 処理をテストしましょう。

`BookInfo` クラスや `BookInfoDB` クラスをテストするには、 `bookinfo.rb` ファイルの末尾に <<program_name_sec_rb>> のようなテスト用コードを追加します。

[[program_name_sec_rb]]
.【Ruby】 `bookinfo.rb` にテストコードを追加する
[example]
--
[source,ruby,linenums]
----

# BookInfoクラス、BookInfoDBクラスの定義（省略）


if $PROGRAM_NAME == __FILE__ # <1>
  bookinfo1 = BookInfo.new('fujii2019', 'アフターデジタル', '藤井、尾原', 2019, '9784296101627')
  bookinfo2 = BookInfo.new('udagawa2019', '他社と働く', '宇田川',  2019, '9784910063010')
  info_db = BookInfoDB.new('bookinfo_test.db')
  info_db.add(bookinfo1)
  info_db.add(bookinfo2)

  id = 'kuboaki2021'
  puts "not found" unless info_db.exists?(id)

  id = 'fujii2019'
  puts 'found' if info_db.exists?(id)

  info = info_db.fetch(id)
  info.each_pair do |key, val|
    puts "#{key}: #{val}"
  end

  list = info_db.list
  p list

  id = 'fujii2019'
  info_db.delete(id)
  puts 'not found' unless info_db.exists?(id)  

  list = info_db.list
  p list
end
----
<1> 実行時ファイル名（ `$PROGRAM_NAME` ）がこのファイルの名前（ `__FILE__` ）と同じなら以下のブロックを実行する。そうでない（他のファイルからrequireされている）ときは実行しない。
--


[NOTE]
--
テストが追加できたら、コミットしておきます。
--



そして、 <<bookinfo_test>>  のように実行すると、このテストコードが実行されます。
また、この部分は、 `bookinfo.rb` が他のクラスから参照されている場合には無視されます。

[[bookinfo_test]]
.`bookinfo.rb` をテストする
[example]
--
[source, console]
----
app_develop> ruby bookinfo.rb # <1>
----
<1> `bookinfo.rb` を直接実行すると、テストコードの部分が実行される。
--


[NOTE]
--
テストが実行できたら、コミットしておきます。
--

== まとめ

開発プロセスに沿って蔵書管理アプリケーションを開発してみました。
この演習によって、分析、設計、実装という開発の工程の役割について、理解が深まったのではないでしょうか。


[NOTE]
--
必要なコミットを済ませたら、リモート（GitHub側）へプッシュしましょう。
--
